cout << "\n";
cout << "  Navier-Stokes Problem:\n";
cout << "  FreeFem++ version.\n";
cout << "  Solve for steady Navier Stokes flow in a cavity.\n";

include "ffmatlib.idp"
//Parametros
int n = 25;
real nu = 1;
real tol = 1e-9;
real epsln = 1e-10;
real delta = 1.;

//Malla
border a(t=0,1.0){x=t; y=0; label=1;};
border b(t=0,1.0){x=1; y=t; label=2;};
border c(t=1.0,0){x=t; y=1; label=3;};
border d(t=1.0,0){x=0; y=t; label=4;};
mesh Th = buildmesh (a(n) + b(n) + c(n) +d(n));
plot(Th, wait=1);


//Fespace
fespace Vh(Th, [P2, P2]);
Vh [ux, uy], [vx, vy], [ux1, uy1], [dux, duy];

fespace Qh(Th, P1);
Qh p, q, dp;


fespace Ph(Th,P0);
Ph pp, qq;

fespace Vh0(Th,P0); 
Vh0 h = hTriangle;

real hmax = h[].max;

func g = 1;


//Macro
macro Gradient(u) [dx(u), dy(u)] //
macro Divergence(ux, uy) (dx(ux) + dy(uy)) //
macro UgradV(ux,uy,vx,vy) [ [ux,uy]'*[dx(vx),dy(vx)] , [ux,uy]'*[dx(vy),dy(vy)] ]//

macro NS() {
 int k;
 real err=0;
 Stokes;
/* Newton Loop  */
 for(k=0; k< 15; k++) {
   LinNS;
   dux[] = ux1[] - ux[];
   duy[] = uy1[] - uy[];
   err = sqrt(int2d(Th)(Gradient(dux)'*Gradient(dux)+Gradient(duy)'*Gradient(duy))) /
     sqrt(int2d(Th)(Gradient(ux)'*Gradient(ux) + Gradient(uy)'*Gradient(uy)));
   ux[] = ux1[];
   uy[] = uy1[];
   cout << "error = " << err << " / " << "tol = " << tol << endl;
   cout.flush;
   if(err < tol) break;
 }
 /* Newton loop has not converged */
 if(err > tol) {
   cout << "NS Warning : non convergence : err = " << err << " / eps = " << tol << endl;
 }

} //

//Problem
problem Stokes ([ux, uy, p],[vx, vy, q])
	= int2d(Th)(nu * (Gradient(ux)' * Gradient(vx)
		+ Gradient(uy)' * Gradient(vy))
		- p * Divergence(vx, vy)
		- Divergence(ux, uy) * q)
     +on(1,2,3,4,uy=0.)
     +on(1,2,4, ux=0)
     +on(3, ux=g);

problem LinNS([ux1,uy1,dp],[vx,vy,q]) =
     int2d(Th)(nu*(Gradient(ux1)'*Gradient(vx)
               +   Gradient(uy1)'*Gradient(vy))
	       + UgradV(ux1,uy1, ux, uy)'*[vx,vy]
	       + UgradV(ux,uy,ux1,uy1)'*[vx,vy]
	       + Divergence(ux1,uy1)*q + Divergence(vx,vy)*dp)
     -int2d(Th)(UgradV(ux,uy, ux, uy)'*[vx,vy])
     +on(1,2,3,4,uy1=0.)
     +on(1,2,4, ux1=0)
     +on(3, ux1=g);

NS;

//Save mesh
//savemesh(Th,"mesh_square.msh");
//Save finite element space connectivity
//ffSaveVh(Th,Vh,"espacio_Vh.txt");
//Save some scalar data
//ffSaveData(p,"presion.txt");
//Save a 2D vector field
//ffSaveData2(ux,uy,"velocidad.txt");

//cout << ux[].n << endl;
//cout << p[].n << endl;

//Plot
plot(p, wait=1, value=1, fill=1);//, ps="pressure.ps", wait=1, value=1, fill=1);
plot([ux, uy], value=1);//, ps="velocity.ps", value=1, coef=.05);